#!/usr/bin/env php
<?php # vim:ts=2:sw=2:et:
/* Copyright (c) 2010 Message Systems, Inc.
 * Author: Wez Furlong
 * License: Modified BSD, See LICENSE file.
 */

/* if true, create branches for impure tags, otherwise activity
 * will be tracked in a fixup branch */
$branch_for_impure_tags = false;

/* if true, generate empty blobs in the target repo; makes it
 * faster to test and verify */
$dummy_blobs = false;

/* if true, pipe through git fast-import, otherwise, generate a
 * file named git.dump */
$pipe_via_import = true;

/* if true, look for and factor in svn:mergeinfo to merge history */
$use_mergeinfo = false;

/* name of file to hold sha1 -> mark mapping generated by Git */
$git_mark_file = 'git.marks';

/* name of file to hold revision -> sha1 mapping generated by this tool.
 * You may use this file to verify the correctness of the conversion;
 * Given a row like this:
 *
 *    18 22ee9fce0700b625864caef888a3d563c42bc7ab
 *
 * This indicates that svn revision [18] maps to Git commit 22ee9f.
 * You can compare the diffs:
 * svn diff ... -c 18
 * git diff '22ee9fce0700b625864caef888a3d563c42bc7ab^..22ee9fce0700b625864caef888a3d563c42bc7ab'
 */
$svn_mark_file = 'svn.marks';

/* regex that specifies files to be excluded */
$exclusion_regex = null;

/* the subversion dump file to use as input */
$svn_dump_file = null;

/* name of file to use to cache analysis information. */
$analyze_cache = '.ana';

/* what we are going to do */
$mode = null;

/* name of target git repo; if specified, will run git fast-import */
$target_git_repo_location = null;

/* name of target dump file for git fast-import; if specified, will
 * generate the dump file but will not modify the git repo */
$target_git_dump_file = null;

/* name of the main line branch */
$mainline_branch = 'trunk';

/* number of revisions to process */
$limit = null;

/* branches to follow */
$follow = array();

/* branch name rewrite rules; each entry is of the form:
 * /pattern/replacement/
 */
$branch_rewrite_rules = array();

/* path to file containing author information */
$authors_file = null;

/* whether to annotate commit messages with a marker that identifies
 * the original SVN commit */
$annotate_commit = false;

$opt = getopt(
  '',
  array(
    "use-mergeinfo",
    "no-blobs",
    "mainline:",
    "git-mark-file:",
    "git-dump-file:",
    "git-repo:",
    "svn-mark-file:",
    "exclude-pattern:",
    "svn-dump:",
    "cache:",
    "analyze",
    "complete",
    "limit:",
    "branch:",
    "exclude-branch:",
    "authors:",
    "annotate-commit",
    "rewrite-branch-name:",
    "help",
  )
);

if (isset($opt['help']) || count($opt) == 0) {
  echo <<<TXT
svn-to-git
by Wez Furlong <http://github.com/wez/svn-to-git>
Copyright (c) 2010, Message Systems, Inc.

Convert a Subversion repository to Git.

Mandatory Options:

  --svn-dump /path/to/dump/file

       The dump file can be created using "svnadmin dump".
       Do NOT use --incremental or --deltas; just use a straight-up
       dump and create a dump format version 2 file.

Common Options:

  --git-repo /path/to/git/repo/dir

       Specify the target Git repo.  This must exist and be already
       initialized.  You can do this for yourself:

            $ mkdir /path/to/git/repo/dir
            $ git init /path/to/git/repo/dir

       If you do not specify a target, svn-to-git will stop after the
       analysis stage.

  --authors /path/to/author/file

       The author file enables mapping from Subversion usernames to
       Git author information, which includes the full name and email
       address.  The file format is compatible with the git-svn authors
       file; each line is a mapping entry of the form:

          subversionuser = FirstName LastName <email@domain>

       A listing of subversion users that are defined in the map is
       printed out after the analysis phase of processing.

       You may want to use the --analyze option to cause processing
       to stop at that point so that you can flesh out the authors
       file.

  --mainline trunk

       Specify the mainline branch; this will named "master" in the
       Git repository.  The default is trunk, but you may specify an
       alternative location in the repo if you have multiple projects
       and want to convert a specific project.

  --branch branches/foo/bar

       Indicate that the named subversion branch should be included
       in the Git repository.  svn-to-git will infer branches based
       on the copy/merge activity associated with the mainline branch,
       but may get confused if the first activity occurs within a
       sub-directory of the true branch.

       svn-to-git will halt during analysis if a merge is made to
       one of the followed branches from an area outside of the followed
       branches.  In this situation, you will be prompted to use either
       --branch or --exclude-branch to enable tracking of the foreign
       branch.  The analysis must then be re-run from the start.

       --branch can be used multiple times.

  --exclude-branch branches/foo/bar

       Indicate that the named subversion branch should not be included
       in the Git repository.

       This does not perform 100% of the intended actions, as some
       activity is sourced from the excluded area and needs to be
       tracked during the import.  It does cause the import to ignore
       activity on excluded branches that is not directly related
       to the mainline, however.
       
       --exclude-branch can be used multiple times.

Less Common Options:

  --analyze

       Causes svn-to-git to halt after performing analysis.
       The data it gathered is cached.  You may complete a run using
       the cached analysis data via the --complete option.

  --complete

       Resume operation after the analysis step.

  --limit 1000

       Limit the import to processing the specified number of revisions.
       This is useful for testing a limited run of the conversion.
       You may specify differing limits for the analysis and completion
       stages if you wish.  The completion stage will adjust its limit
       so that it does not exceed the number of revisions processed
       during analysis.

  --no-blobs

       If specified, the Git import will use empty files instead of
       the actual data from the repository.  This allows for a fast
       import to verify that the metadata and branching is correct.

  --git-dump-file /path/to/dump/file

       If used in place of --git-repo, instead of running the import,
       the data feed that would have been passed to "git fast-import"
       is output to the specified file.  This allows inspection of
       the data feed, but will take longer to apply to the target
       Git repository.

  --use-mergeinfo

       If specified, svn:mergeinfo properties will be used to infer
       merge information.  This works best when the repository was
       created with that information from the outset.

       This capability is disabled by default.

  --exclude-pattern regex

       When specified, any file names that match this regex will
       be suppressed from the import.

  --annotate-commit

       When specified, the commit log provided to Git will be annotated
       with the origin subversion changeset number.

  --rewrite-branch-name @^branches/(.*)$@$1@

       When the branch name is computed, the base behavior is to strip off
       a prefix of "branches/", which works well for the default repo layout.
       If you have more complex layouts, you may specify any number of
       replacement patterns to use.

Rare Options:

  --git-mark-file git.marks

       If specified, allows the git.marks file path to be changed.
       The default is to create git.marks in the current directory.
       The Git marks file is used to generate the svn mark file.

  --svn-mark-file svn.marks

       If specified, allows the svn.marks file path to be changed.
       The default is to create svn.marks in the current directory.

       The contents of this file contain a mapping of subversion changeset
       number to Git commit SHA-1 hash.

       This is provided to aid in the verification of the migration.

  --cache .ana

       If specified, allows the analysis cache file path to be changed.
       The default is to create .ana in the current directory.
       This cache file is used to complete processing in two stages.


TXT;
  exit(0);
}

if (isset($opt['svn-dump'])) {
  $svn_dump_file = $opt['svn-dump'];
}
if ($svn_dump_file === null || !file_exists($svn_dump_file)) {
  echo "FATAL: you must specify --svn-dump /path/to/dump\n";
  echo "FATAL: use --help to show usage options\n";
  echo "FATAL: note that 32-bit versions of PHP may not be able\n";
  echo "FATAL: to see dump files that are larger than 2GB in size\n";
  exit(1);
}
if (isset($opt['git-repo'])) {
  $target_git_repo_location = $opt['git-repo'];
  if (!is_dir($target_git_repo_location)) {
    echo "FATAL: git-repo $target_git_repo_location is not a directory\n";
    exit(1);
  }
  if (!is_dir("$target_git_repo_location/.git")) {
    echo "FATAL: git-repo $target_git_repo_location/.git is not a directory\n";
    exit(1);
  }
}
if (isset($opt['git-dump-file'])) {
  $target_git_dump_file = $opt['git-dump-file'];
}

$AUTHOR_MAP = array();

if (isset($opt['authors'])) {
  $authors_file = $opt['authors'];
  foreach (file($authors_file) as $line) {
    if (preg_match("/^\s*(\S+)\s*=\s*(.*)\s*$/", $line, $M)) {
      $AUTHOR_MAP[$M[1]] = $M[2];
    }
  }
}
if (isset($opt['mainline'])) {
  $mainline_branch = $opt['mainline'];
}
if (isset($opt['cache'])) {
  $analyze_cache = $opt['cache'];
}
if (isset($opt['git-mark-file'])) {
  $git_mark_file = $opt['git-mark-file'];
}
$mark_dir = dirname($git_mark_file);
if ($mark_dir == '.') {
  $mark_dir = getcwd();
} else {
  $mark_dir = realpath($mark_dir);
}
$git_mark_file = $mark_dir . '/' . $git_mark_file;

if (isset($opt['svn-mark-file'])) {
  $svn_mark_file = $opt['svn-mark-file'];
}
if (isset($opt['exclude-pattern'])) {
  $exclusion_regex = $opt['exclude-pattern'];
}
if (isset($opt['limit'])) {
  $limit = (int)$opt['limit'];
}
if (isset($opt['branch'])) {
  if (is_array($opt['branch'])) {
    foreach ($opt['branch'] as $b) {
      $follow[$b] = true;
    }
  } else {
    $follow[$opt['branch']] = true;
  }
}
if (isset($opt['rewrite-branch-name'])) {
  if (is_array($opt['rewrite-branch-name'])) {
    foreach ($opt['rewrite-branch-name'] as $b) {
      $rules[] = $b;
    }
  } else {
    $rules[] = $opt['rewrite-branch-name'];
  }
  foreach ($rules as $rule) {
    $delim = $rule[0];
    list($empty, $search, $replace, $options) = explode($delim, $rule);

    $search = $delim . $search . $delim . $options;

    $branch_rewrite_rules[$search] = $replace;
  }
}
if (isset($opt['exclude-branch'])) {
  if (is_array($opt['exclude-branch'])) {
    foreach ($opt['exclude-branch'] as $b) {
      $follow[$b] = false;
    }
  } else {
    $follow[$opt['exclude-branch']] = false;
  }
}
$use_mergeinfo = isset($opt['use-mergeinfo']);
$dummy_blobs = isset($opt['no-blobs']);
$annotate_commit = isset($opt['annotate-commit']);
if (isset($opt['analyze'])) {
  $mode = 'ANALYZE';

  if (isset($opt['complete'])) {
    echo "FATAL: you may not use both --analyze and --complete together\n";
    exit(1);
  }
} else if (isset($opt['complete'])) {
  if (!file_exists($analyze_cache)) {
    echo "FATAL: cache file $analyze_cache was not found; did you forget\n";
    echo "to run with --analyze?\n";
    exit(1);
  }
  $mode = 'COMPLETE';
}

include 'svndump.php';
include 'util.php';

date_default_timezone_set('America/New_York');

if ($mode === null || $mode == 'ANALYZE') {
  $S = new Repo;
  $S->limit = $limit;
} else {
  $S = unserialize(file_get_contents($analyze_cache));

  if (($limit === null && $S->limit !== null) ||
      ($S->limit !== null && $limit > $S->limit)) {
    $limit = $S->limit;
    echo "NOTICE: setting limit to $limit\n";
  }
}

$R = new SvnDumpReader($svn_dump_file);

function is_child_of($candidate, $parent)
{
  if (!strncmp($candidate, $parent, strlen($parent))) {
    if (strlen($candidate) == strlen($parent) ||
        $candidate[strlen($parent)] == '/') {
      return true;
    }
  }
  return false;
}

function is_excluded($name)
{
  global $exclusion_regex;

  if ($exclusion_regex === null) {
    return false;
  }

  return preg_match("/" . $exclusion_regex . "/", $name);
}

if ($mode === null || $mode == 'ANALYZE') {
  echo "NOTICE: Analyzing dump file\n";
  $climit = $limit;
  $authors = array();
  while ($climit === null || $climit--) {
    if (!$R->next()) {
      echo "NOTICE: reached end of SVN data\n";
      break;
    }
    if (isset($R->revprops['svn:author'])) {
      $authors[$R->revprops['svn:author']] = true;
    }
    list($log) = explode("\n", $R->revprops['svn:log']);
    $log = substr($log, 0, 40);
    echo "DEBUG: ", $R->revision, " $log\n";
    foreach ($R->nodes as $node) {
#    echo "  $node->path\n";
      $b = $S->find_branch($node);

      if ($b === null) {
        /* branch not found */
        if (is_child_of($node->path, $mainline_branch)) {
          /* create trunk */
          $b = $S->add_branch($node);
          continue;
        }
        foreach ($follow as $candidate => $include) {
          if (is_child_of($node->path, $candidate)) {
            $b = $S->add_branch($node);
            $b->include = $include;
            break;
          }
        }
        if ($b) {
          continue;
        }

        /* is this the creation of an interesting branch? */
        if (isset($node->meta['node-copyfrom-path'])) {
          $ob = $S->find_branch(
                    $node->meta['node-copyfrom-path'],
                    $node->meta['node-copyfrom-rev']);

          if ($ob) {
            if ($node->kind == 'file') {
              $name = dirname($node->path);
            } else {
              $name = $node->path;
            }
            $b = $S->add_branch($name, $R->revision);
            $b->origin = $ob;
            $b->include = $ob->include;
            continue;
          }
        }

        /* otherwise, uninteresting; ignore it */
      } else {
        /* record activity against this revision */
        $b->addActivity($R);

        if ($node->action == 'delete' && $node->path == $b->name) {
          $S->delete_branch($b, $node->revision);
        }

        /* check for copy in */
        if (isset($node->meta['node-copyfrom-path'])) {
          $ob = $S->find_branch(
                  $node->meta['node-copyfrom-path'],
                  $node->meta['node-copyfrom-rev']);
          if ($ob === null) {
            $src = $node->meta['node-copyfrom-path'];
            $dest = $node->path;

            echo <<<TXT

  ** Foreign Merge Detected:
  Source: $src
  Destination: $dest

  This happens when development occurs outside of the obvious branches.
  Since this tool follows the flow of changes from the roots you have specified,
  it does not have enough history to continue without some hints on your part.

  If you'd like to track the history of the source of this change, determine
  the base dir of the source and re-run this tool with a flag like this:

    --branch "$src"

  If you instead, you'd like to treat this change as a net-new copy in,
  determine the basedir of the source and re-run this tool with a flag
  like this:

    --exclude-branch "$src"

TXT;
            exit;
          }
        }
      }
    }
  }
  $included_branches = array();
  $included_tags = array();
  $excluded_branches = array();
  $excluded_tags = array();
  $dead_branches = array();
  $dead_tags = array();
  foreach ($S->branches as $b) {
    if ($b->include) {
      if ($b->is_tag) {
        $included_tags[] = "$b->name ($b->bname)";
      } else {
        $included_branches[] = "$b->name ($b->bname)";
      }
    } else if ($b->is_tag) {
      $excluded_tags[] = "$b->name ($b->bname)";
    } else {
      $excluded_branches[] = "$b->name ($b->bname)";
    }
  }
  foreach ($S->dead_branches as $bname => $bdata) {
    foreach ($bdata as $b) {
      if ($b->is_tag) {
        $dead_tags[] = "$b->name ($b->bname)";
      } else {
        $dead_branches[] = "$b->name ($b->bname)";
      }
    }
  }
  asort($included_branches);
  asort($included_tags);
  asort($excluded_branches);
  asort($excluded_tags);
  asort($dead_branches);
  asort($dead_tags);
  echo "NOTICE: Will include the following branches:\n";
  echo "  " . join("\n  ", $included_branches) . "\n";
  echo "NOTICE: Will include the following tags:\n";
  echo "  " . join("\n  ", $included_tags) . "\n";
  echo "NOTICE: Will exclude the following branches:\n";
  echo "  " . join("\n  ", $excluded_branches) . "\n";
  echo "NOTICE: Will exclude the following tags:\n";
  echo "  " . join("\n  ", $excluded_tags) . "\n";
  echo "NOTICE: tracking commits from the following dead branches:\n";
  echo "  " . join("\n  ", $dead_branches) . "\n";
  echo "NOTICE: tracking commits from the following dead tags:\n";
  echo "  " . join("\n  ", $dead_tags) . "\n";

  echo "DEBUG: serialize analysis\n";

  $unmapped = false;
  foreach ($authors as $author => $dummy) {
    if (!isset($AUTHOR_MAP[$author])) {
      echo "NOTICE: unmapped author: $author\n";
      $unmapped = true;
    }
  }
  if ($unmapped) {
    echo "NOTICE: use the author file to supply mapping information\n";
    echo "NOTICE: format is:  svnusername = First Last <email@domain>\n";
  }

  file_put_contents($analyze_cache, serialize($S));

  if ($mode == 'ANALYZE') {
    echo "NOTICE: stopping at analysis stage\n";
    exit(0);
  }
  $R->rewind();
}

/* now generate a dump file suitable for consumption by git-fast-import */

if (is_dir($target_git_repo_location)) {
  $GIT_FAST_IMPORT = proc_open(
    "git fast-import --export-marks=" . escapeshellarg($git_mark_file),
    array(
      0 => array("pipe", "r"),
      1 => STDOUT,
      2 => STDERR
    ),
    $pipes,
    $target_git_repo_location
  );
  $exp = $pipes[0];
  echo "NOTICE: Allow git fast-import a few moments to spawn\n";
  sleep(10);
} else if ($target_git_dump_file !== null) {
  $exp = fopen($target_git_dump_file, 'wb');
  $GIT_FAST_IMPORT = null;
} else {
  echo "FATAL: need to specify a target git repo or dump file\n";
  exit(1);
}

$nextmark = 1;
$mark_cache = array();

/* so we can determine new merge sources */
$mergeprops_by_path = array();

function parse_mergeinfo_props($minfo)
{
  $range_by_src = array();

  // One specifier per line
  // /branches/2.2:27026-27044
  // /branches/2.2:28649,28732,28759

  foreach (explode("\n", $minfo) as $mdata) {
    list($source, $range) = explode(':', $mdata, 2);

    $N = array();

    foreach (explode(',', $range) as $item) {
      $numbers = explode('-', $item, 2);
      if (count($numbers) == 2) {
        for ($i = (int)$numbers[0]; $i <= (int)$numbers[1]; $i++) {
          $N[$i] = $i;
        }
      } else {
        $i = $numbers[0];
        $N[$i] = $i;
      }
    }

    if (!isset($range_by_src[$source])) {
      $range_by_src[$source] = $N;
    } else {
      foreach ($N as $i => $v) {
        if (!isset($range_by_src[$source][$i])) {
          $range_by_src[$source][$i] = $v;
        }
      }
    }
  }

  return $range_by_src;
}

function diff_mergeinfo_props(SvnDumpNode $node)
{
  global $mergeprops_by_path;
  global $S;

  $new = array();

  if (isset($mergeprops_by_path[$node->path])) {
    $cinfo = $mergeprops_by_path[$node->path];
  } else {
    $cinfo = array();
  }

  $ninfo = parse_mergeinfo_props($node->props['svn:mergeinfo']);

  $res = array();

  /* I've opted to ignore the mergeinfo properties by default.
   * They are worthwhile if you whole history has good mergeinfo,
   * but are a PITA to figure out on top of years of prior history. */
  /* we ignore deletes; use the new info as the driver for new merges */
  foreach ($ninfo as $path => $range) {
    if (!isset($cinfo[$path])) {
      /* this whole range is new */
      foreach ($range as $rev) {
        $new[$path][$rev] = $rev;
      }
    } else {
      /* need to compute the difference */
      foreach (array_diff($range, $cinfo[$path]) as $rev) {
        $new[$path][$rev] = $rev;
      }
    }
  }

  foreach ($new as $path => $revdata) {
    // svn tracks mergeinfo paths with a leading slash; fixup
    $bpath = ltrim($path, '/');
    foreach ($revdata as $rev) {
      $b = $S->find_branch($bpath, $rev);
      $s = new stdclass;
      $s->branch = $b->name;
      $s->rev = $rev;
      $res[] = $s;
    }
  }

  $mergeprops_by_path[$node->path] = $ninfo;
  return $res;
}

function map_author($name)
{
  global $AUTHOR_MAP;

  if (isset($AUTHOR_MAP[$name])) {
    return $AUTHOR_MAP[$name];
  }

  $str = "$name <$name@example.com>";
  $AUTHOR_MAP[$name] = $str;
  return $str;
}

echo "NOTICE: Generating Git export file\n";
$TAG_FIXUP = array();
$climit = $limit;
while ($climit === null || $climit--) {
  if (!$R->next()) {
    break;
  }
  $rev = $R->revision;

  /* is this commit one our interesting commits? */
  $affected_branches = array();
  $node_by_branch = array();
  $local_branch_by_name = array();

  foreach ($R->nodes as $node) {
    $b = $S->find_branch($node);
    $local_branch_by_name[$b->name] = $b;
    if ($b === null) {
      continue;
    }
    if (!$b->include) {
      continue;
    }
    if (!isset($affected_branches[$b->name])) {
      $affected_branches[$b->name] = $b;
      $node_by_branch[$b->name] = array();
    }
    $node_by_branch[$b->name][] = $node;
  }

  if (count($affected_branches) == 0) {
    // not a region of the repo that we find interesting right now
    echo "[$rev] skip\n";
    continue;
  }

  /* cvs2svn manufactured commits */
  if (!isset($R->revprops['svn:author'])) {
    $R->revprops['svn:author'] = 'cvs2svn';
  }

  echo "[$rev]\n";

  foreach ($node_by_branch as $bname => $nodes) {
    $b = $local_branch_by_name[$bname];
//    var_dump($nodes);

    $merge_sources = array();

    /* first pass through to mark any blobs we're putting in */
    foreach ($nodes as $node) {

      /* also check for svn merge information */
      if ($use_mergeinfo &&
          isset($node->props['svn:mergeinfo']) &&
          strlen($node->props['svn:mergeinfo'])) {
        foreach (diff_mergeinfo_props($node) as $msource) {
          $mkey = "commit-$msource->branch-$msource->rev";
          if (isset($mark_cache[$mkey])) {
            $mid = $mark_cache[$mkey];
            fwrite($exp, "# adding $mid as merge source due to svn:mergeinfo\n");
            $merge_sources[$mid] = $mid;
          }
        }
      }

      if ($node->kind != 'file') continue;
      if (is_excluded($node->path)) continue;

      switch ($node->action) {
        case 'add':
        case 'change':
        case 'replace':
          if ($node->sha1 === null) {
            if (isset($node->meta['node-copyfrom-rev']) &&
                isset($node->meta['node-copyfrom-path'])) {
              /* dup a prior mark */
              $crev = $node->meta['node-copyfrom-rev'];
              $cpath = $node->meta['node-copyfrom-path'];

              $cb = $S->find_branch($cpath, $crev);
              if ($cb && isset($mark_cache["commit-$cb->name-$crev"])) {
                $mid = $mark_cache["commit-$cb->name-$crev"];
                $merge_sources[$mid] = $mid;
                fwrite($exp, "# adding $mid as merge source due to copy from $node->path\n");
              }
              if (isset($mark_cache["file:$crev@$cpath"])) {
                /* make an alias */
                $mark_cache["file:$rev@$node->path"] =
                  $mark_cache["file:$crev@$cpath"];
                break;
              }
              if (isset($node->meta['text-copy-source-sha1'])) {
                $sha1 = $node->meta['text-copy-source-sha1'];
                if (isset($mark_cache["sha1:$sha1"])) {
                  /* make an alias */
                  $mark_cache["file:$rev@$node->path"] =
                    $mark_cache["sha1:$sha1"];
                  break;
                }
              }
            } elseif ($node->action == 'change') {
              /* property only change */
              break;
            }
            /* let's go looking for a node in the dump that has the text */
            $sb = $S->find_branch(
                    $node->meta['node-copyfrom-path'],
                    $node->meta['node-copyfrom-rev']);
            if ($sb) {
              $spath = $node->meta['node-copyfrom-path'];
              $mid = null;
              for ($srev = $node->meta['node-copyfrom-rev']; $srev > 0; $srev--)
              {
                if (!isset($sb->activity_by_path[$spath][$srev])) {
                  continue;
                }
                if (!$R->getByRev($srev)) {
                  echo "couldn't seek to rev $srev\n";
                  break;
                }
                foreach ($R->nodes as $snode) {
                  if ($snode->path != $spath) {
                    continue;
                  }
                  if ($snode->sha1 === null) {
                    // FIXME: recursively follow copies
                    echo "FIXME: recursive follow\n";
                    echo "FIXME: workaround this by using --branch instead of --exclude-branch for $spath\n";
                    var_dump($snode);
                    break;
                  }
                  if (isset($mark_cache["sha1:$snode->sha1"])) {
                    $mid = $mark_cache["sha1:$snode->sha1"];
                  } else {
                    $mid = $nextmark++;
                    $mark_cache["sha1:$snode->sha1"] = $mid;
                    fwrite($exp, "# mark for $snode->path $snode->sha1 $mid\n");
                    if ($dummy_blobs) {
                      fprintf($exp, "blob\nmark :%d\ndata 0\n", $mid);
                    } else {
                      fprintf($exp, "blob\nmark :%d\ndata %d\n", $mid,
                        $snode->size);
                      $snode->streamText($R, $exp);
                    }
                    fwrite($exp, "\n");
                  }
                  $mark_cache["file:$rev@$node->path"] = $mid;
                  break;
                }
              }
              // re-sync back to current revision
              $R->getByRev($rev);
              if ($mid !== null) {
                break;
              }
            }
            echo "Don't know how to get at text for node:\n";
            var_dump($node);
            echo "sb is $sb\n";
            exit;
          }
          if (isset($mark_cache["sha1:$node->sha1"])) {
            $mid = $mark_cache["sha1:$node->sha1"];
          } else {
            $mid = $nextmark++;
            $mark_cache["sha1:$node->sha1"] = $mid;
            fwrite($exp, "# mark for $node->path $node->sha1 $mid\n");
            if ($dummy_blobs) {
              fprintf($exp, "blob\nmark :%d\ndata 0\n", $mid);
            } else {
              fprintf($exp, "blob\nmark :%d\ndata %d\n", $mid, $node->size);
              $node->streamText($R, $exp);
            }
            fwrite($exp, "\n");
          }
          $mark_cache["file:$rev@$node->path"] = $mid;
          break;

        case 'delete':
          break;

        default:
          var_dump($node);
          echo "Unhandled action $node->action\n";
          exit;
      }
    }

    $author = map_author($R->revprops['svn:author']);
    $when = strtotime($R->revprops['svn:date']);
    $log = $R->revprops['svn:log'];
    if ($annotate_commit) {
      $log = "(svn: [$rev] on $b->name : $b->bname)\n" . $log;
    }

    /* don't bother recording a tag if it is deleted */
    if ($b->include && $b->is_tag && $b->is_pure && $b->createdrev == $rev &&
        $b->deleted === null) {
      foreach ($nodes as $node) {
        if ($node->action == 'add' && $node->path == $b->name) {
          break;
        }
      }

      if ($node->meta['node-copyfrom-path'] !=
          $b->origin->name) {
        var_dump($node);
        throw new Exception("didn't tag from branch root!");
      }
      $bsrc = $b->origin->name;
      /* walk back until we find what is probably the right commit */
      $brev = (int)$node->meta['node-copyfrom-rev'];
      $mid = null;
      while ($mid === null) {
        $mid = $mark_cache["commit-$bsrc-$brev"];
        if ($mid !== null) {
          break;
        }
        if ($brev-- == 0) {
          break;
        }
      }
      if ($brev == 0) {
        echo "$b\n";
        echo "bsrc=$bsrc\n";
        var_dump($node);
        throw new Exception("did not find source commit");
      }
      fprintf($exp, "tag %s\nfrom :%d\n", $b->bname,
        $mark_cache["commit-$bsrc-$brev"]);
      $mark_cache["commit-$b->name-$rev"] = $mark_cache["commit-$bsrc-$brev"];
      fprintf($exp,
        "tagger $author $when -0000\n");
        fprintf($exp, "data %d\n%s\n", strlen($log), $log);

      continue;
    }

    fwrite($exp, "# svn [$rev]\n");
    fwrite($exp, "progress rev [$rev]\n");

    /* figure out whether we need to kill or re-create the branch.
     * This is made more complicated by the possibility for one svn
     * commit to both delete and create in the same commit */

    $commit_source = null;

    foreach ($nodes as $node) {
      if (is_excluded($node->path)) continue;
      if ($node->path == $b->name) {
        if ($node->action == 'add') {
          if (isset($node->meta['node-copyfrom-path'])) {
            $spath = $node->meta['node-copyfrom-path'];
            $srev = $node->meta['node-copyfrom-rev'];
            $sb = $S->find_branch($spath, $srev);
            if (!$sb) {
              echo "FATAL: could not locate source branch $spath @ $srev\n";
              echo "FATAL: while recreating $b->name @ $rev\n";
              exit(1);
            }
            $mid = null;
            while ($mid === null) {
              $mid = $mark_cache["commit-$sb->name-$srev"];
              if ($mid !== null) {
                break;
              }
              if ($srev-- == 0) {
                break;
              }
            }
            if ($mid !== null) {
              $commit_source = $mid;
            } else {
              echo "FATAL: could not find mark for source $spath @ $srev\n";
              echo "FATAL: while recreating $b->name @ $rev\n";
              exit(1);
            }
          }
        }
      }
    }

    if ($b->deleted !== null ||
        ($b->is_tag && !$b->is_pure && !$branch_for_impure_tags)) {
      $TAG_FIXUP[$b->bname] = $b->bname;
      fprintf($exp, "commit TAG_FIXUP/$b->bname\n");
    } else {
      fprintf($exp, "commit refs/heads/$b->bname\n");
    }
    $mid = $nextmark++;
    $mark_cache["commit-$b->name-$rev"] = $mid;
    $mark_cache["commitbyrev-$rev"] = $mid;
    fwrite($exp, "# mark for commit $b->name [$rev] $mid\n");
    fprintf($exp, "mark :%d\n", $mid);
    $future_last_mark = $mid;

    fprintf($exp,
      "committer $author $when -0000\n");
    fprintf($exp, "data %d\n%s\n", strlen($log), $log);
    if ($commit_source !== null) {
      fprintf($exp, "from :%d\n", $commit_source);
    } else if ($b->createdrev == $rev && $b->origin !== null) {
      if ($b->origin->last_mark) {
        fprintf($exp, "from :%d\n", $b->origin->last_mark);
      } else {
        var_dump($nodes);
        echo "created in this rev, but have no last mark\n";
        echo "$b\nOrigin: $b->origin\n";
        exit(1);
      }
    }

    if (preg_match("/(?:merge|take)/i", $R->revprops['svn:log']) &&
        preg_match_all("/(?:^|\s|,)(\[\d+\]|r\d+|\d+)(?:,|\s|$)/sm",
          $R->revprops['svn:log'], $M)) {
      foreach ($M[1] as $mrev) {
        $srev = (int)preg_replace("/[^0-9]/", '', $mrev);
        if (!isset($mark_cache["commitbyrev-$srev"])) {
          // Can happen if someone typo'd their commit message :-/
          echo "Warning: couldn't find source of merge for [$srev] in [$rev]: $log\n";
        } else {
          $smid = $mark_cache["commitbyrev-$srev"];
          $merge_sources[$smid] = $smid;
          fwrite($exp, "# adding $smid as merge source due to commit log rev $srev\n");
        }
      }
    }

    foreach ($merge_sources as $merge_mark) {
      if ($merge_mark !== $b->last_mark) {
        fprintf($exp, "merge :%d\n", $merge_mark);
      }
    }
    $b->last_mark = $future_last_mark;

    foreach ($nodes as $node) {
      if (is_excluded($node->path)) continue;
      if ($node->path == $b->name && $node->action == 'add') {
        continue;
      }
      if ($node->action == 'delete') {
        if ($node->path == $b->name) {
          continue;
        } else {
          fprintf($exp, "D %s\n", $b->fixpath($node->path));
        }
        continue;
      }
      if ($node->kind == 'file') {
        if ($node->action == 'change' && $node->sha1 === null &&
            !isset($node->meta['node-copyfrom-path'])) {
          /* prop only change */
          echo "[$rev] FIXME: prop only change\n";
          continue;
        }
        if ($node->action == 'add' || $node->action == 'change' ||
            $node->action == 'replace') {
          $mode = isset($node->props['svn:executable']) ? '100755' : '100644';
          fprintf($exp, "M %s :%d %s\n", $mode,
            $mark_cache["file:$rev@$node->path"], $b->fixpath($node->path));
          continue;
        }
      } else if ($node->kind == 'dir') {
        continue;
      }

      var_dump($node);
      echo "What to do?\n";
      exit;
    }
    if ($b->is_tag && $b->include && $b->deleted === null) {
      /* if we get here, check to see if we should create the tag.
       * We must be an impure tag.  We only create impure tags at the point
       * of last activity */
      $final = end($b->activity);
      if ($final) {
        /* if this is the final activity; tag it */
        $mid = $b->last_mark;
        fprintf($exp, "tag %s\nfrom :%d\n", $b->bname, $mid);
        fprintf($exp,
            "tagger $author $when -0000\n");
        fprintf($exp, "data %d\n%s\n", strlen($log), $log);
        $mark_cache["commit-$b->name-$rev"] = $mid;
      }
    }
  }
}

function rmdir_r($path)
{
  if (is_dir($path)) {
    $d = opendir($path);
    while (($file = readdir($d)) !== false) {
      if ($file == '.' || $file == '..') {
        continue;
      }
      $file = "$path/$file";
      if (is_dir($file)) {
        rmdir_r($file);
      } else {
        unlink($file);
      }
    }
    rmdir($path);
  } else {
    unlink($path);
  }
}

fclose($exp);
if (is_resource($GIT_FAST_IMPORT)) {
  proc_close($GIT_FAST_IMPORT);
  /* prune out fixup namespace */
  if (count($TAG_FIXUP)) {
    rmdir_r($target_git_repo_location . "/.git/TAG_FIXUP");
  }
  $GM = array();
  foreach (file($git_mark_file) as $line) {
    if (preg_match("/^:(\d+)\s+([a-f0-9]+)\s*$/", $line, $M)) {
      $GM[$M[1]] = $M[2];
    }
  }
  /* now build out our map of svn changesets also */
  $fp = fopen($svn_mark_file, 'w');
  foreach ($mark_cache as $key => $mid) {
    if (preg_match("/^commitbyrev-(\d+)$/", $key, $M)) {
      fprintf($fp, "%d %s\n", $M[1], $GM[$mid]);
    }
  }
  fclose($fp);
}
